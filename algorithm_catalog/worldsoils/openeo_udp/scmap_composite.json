{
  "process_graph": {
    "loadcollection1": {
      "process_id": "load_collection",
      "arguments": {
        "bands": [
          "B02",
          "B03",
          "B04",
          "B05",
          "B06",
          "B07",
          "B08",
          "B8A",
          "B11",
          "B12"
        ],
        "id": "SENTINEL2_L2A",
        "properties": {
          "eo:cloud_cover": {
            "process_graph": {
              "lte1": {
                "process_id": "lte",
                "arguments": {
                  "x": {
                    "from_parameter": "value"
                  },
                  "y": {
                    "from_parameter": "max_cloud_cover"
                  }
                },
                "result": true
              }
            }
          }
        },
        "spatial_extent": {
          "from_parameter": "bounding_box"
        },
        "temporal_extent": {
          "from_parameter": "temporal_extent"
        }
      }
    },
    "loadcollection2": {
      "process_id": "load_collection",
      "arguments": {
        "bands": [
          "SCL"
        ],
        "id": "SENTINEL2_L2A",
        "properties": {
          "eo:cloud_cover": {
            "process_graph": {
              "lte2": {
                "process_id": "lte",
                "arguments": {
                  "x": {
                    "from_parameter": "value"
                  },
                  "y": {
                    "from_parameter": "max_cloud_cover"
                  }
                },
                "result": true
              }
            }
          }
        },
        "spatial_extent": {
          "from_parameter": "bounding_box"
        },
        "temporal_extent": {
          "from_parameter": "temporal_extent"
        }
      }
    },
    "apply1": {
      "process_id": "apply",
      "arguments": {
        "data": {
          "from_node": "loadcollection2"
        },
        "process": {
          "process_graph": {
            "eq1": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 3
              }
            },
            "eq2": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 8
              }
            },
            "eq3": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 9
              }
            },
            "eq4": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 10
              }
            },
            "eq5": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 1
              }
            },
            "eq6": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 11
              }
            },
            "eq7": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 0
              }
            },
            "eq8": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 2
              }
            },
            "eq9": {
              "process_id": "eq",
              "arguments": {
                "x": {
                  "from_parameter": "x"
                },
                "y": 7
              }
            },
            "arraycreate1": {
              "process_id": "array_create",
              "arguments": {
                "data": [
                  {
                    "from_node": "eq1"
                  },
                  {
                    "from_node": "eq2"
                  },
                  {
                    "from_node": "eq3"
                  },
                  {
                    "from_node": "eq4"
                  },
                  {
                    "from_node": "eq5"
                  },
                  {
                    "from_node": "eq6"
                  },
                  {
                    "from_node": "eq7"
                  },
                  {
                    "from_node": "eq8"
                  },
                  {
                    "from_node": "eq9"
                  }
                ]
              }
            },
            "any1": {
              "process_id": "any",
              "arguments": {
                "data": {
                  "from_node": "arraycreate1"
                }
              },
              "result": true
            }
          }
        }
      }
    },
    "mask1": {
      "process_id": "mask",
      "arguments": {
        "data": {
          "from_node": "loadcollection1"
        },
        "mask": {
          "from_node": "apply1"
        }
      }
    },
    "reducedimension1": {
      "process_id": "reduce_dimension",
      "arguments": {
        "data": {
          "from_node": "mask1"
        },
        "dimension": "bands",
        "reducer": {
          "process_graph": {
            "arrayelement1": {
              "process_id": "array_element",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                },
                "index": 6
              }
            },
            "arrayelement2": {
              "process_id": "array_element",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                },
                "index": 2
              }
            },
            "subtract1": {
              "process_id": "subtract",
              "arguments": {
                "x": {
                  "from_node": "arrayelement1"
                },
                "y": {
                  "from_node": "arrayelement2"
                }
              }
            },
            "add1": {
              "process_id": "add",
              "arguments": {
                "x": {
                  "from_node": "arrayelement1"
                },
                "y": {
                  "from_node": "arrayelement2"
                }
              }
            },
            "divide1": {
              "process_id": "divide",
              "arguments": {
                "x": {
                  "from_node": "subtract1"
                },
                "y": {
                  "from_node": "add1"
                }
              }
            },
            "arrayelement3": {
              "process_id": "array_element",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                },
                "index": 9
              }
            },
            "subtract2": {
              "process_id": "subtract",
              "arguments": {
                "x": {
                  "from_node": "arrayelement1"
                },
                "y": {
                  "from_node": "arrayelement3"
                }
              }
            },
            "add2": {
              "process_id": "add",
              "arguments": {
                "x": {
                  "from_node": "arrayelement1"
                },
                "y": {
                  "from_node": "arrayelement3"
                }
              }
            },
            "divide2": {
              "process_id": "divide",
              "arguments": {
                "x": {
                  "from_node": "subtract2"
                },
                "y": {
                  "from_node": "add2"
                }
              }
            },
            "add3": {
              "process_id": "add",
              "arguments": {
                "x": {
                  "from_node": "divide1"
                },
                "y": {
                  "from_node": "divide2"
                }
              },
              "result": true
            }
          }
        }
      }
    },
    "adddimension1": {
      "process_id": "add_dimension",
      "arguments": {
        "data": {
          "from_node": "reducedimension1"
        },
        "label": "pvir2",
        "name": "bands",
        "type": "bands"
      }
    },
    "mergecubes1": {
      "process_id": "merge_cubes",
      "arguments": {
        "cube1": {
          "from_node": "mask1"
        },
        "cube2": {
          "from_node": "adddimension1"
        }
      }
    },
    "loadstac1": {
      "process_id": "load_stac",
      "arguments": {
        "bands": [
          "S2_s2cr_pvir2_threshold_img"
        ],
        "spatial_extent": {
          "from_parameter": "bounding_box"
        },
        "url": "https://github.com/Schiggebam/dlr_scmap_resources/raw/main/th_S2_s2cr_buffered_stac_yflip.json"
      }
    },
    "resamplecubespatial1": {
      "process_id": "resample_cube_spatial",
      "arguments": {
        "data": {
          "from_node": "loadstac1"
        },
        "method": "bilinear",
        "target": {
          "from_node": "mask1"
        }
      }
    },
    "reducedimension2": {
      "process_id": "reduce_dimension",
      "arguments": {
        "data": {
          "from_node": "resamplecubespatial1"
        },
        "dimension": "bands",
        "reducer": {
          "process_graph": {
            "first1": {
              "process_id": "first",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                }
              },
              "result": true
            }
          }
        }
      }
    },
    "adddimension2": {
      "process_id": "add_dimension",
      "arguments": {
        "data": {
          "from_node": "reducedimension2"
        },
        "label": "th_img",
        "name": "bands",
        "type": "bands"
      }
    },
    "mergecubes2": {
      "process_id": "merge_cubes",
      "arguments": {
        "cube1": {
          "from_node": "mergecubes1"
        },
        "cube2": {
          "from_node": "adddimension2"
        }
      }
    },
    "applydimension1": {
      "process_id": "apply_dimension",
      "arguments": {
        "data": {
          "from_node": "mergecubes2"
        },
        "dimension": "t",
        "process": {
          "process_graph": {
            "runudf1": {
              "process_id": "run_udf",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                },
                "runtime": "Python",
                "udf": "import numpy as np\nimport xarray as xr\nfrom typing import Dict\nfrom openeo.udf.xarraydatacube import XarrayDataCube\n\n\ndef apply_datacube(cube: XarrayDataCube, context: dict) -> XarrayDataCube:\n    \"\"\"\n    This function is executed by apply_dimension(dimension=\"t\").\n    Therefore the input cube has shape:\n\n        dims = ('t', 'bands', 'y', 'x')\n\n    We compute pvir2 for all time slices, compare it with the threshold\n    (which is a separate band), mask the reflectance bands, and then\n    reduce the time dimension by mean.\n    \"\"\"\n    arr: xr.DataArray = cube.get_array()\n\n    # --- Identify bands ---\n    all_bands = list(arr.coords[\"bands\"].values)\n\n    # Reflectance bands B02..B12 (three characters and starting with B)\n    refl_bands = [b for b in all_bands if b.startswith(\"B\") and len(b) == 3]\n\n    # Threshold band\n    th_band = \"th_img\"\n\n    # --- Select subsets ---\n    refl = arr.sel(bands=refl_bands)\n    b04  = arr.sel(bands=\"B04\")\n    b08  = arr.sel(bands=\"B08\")\n    b12  = arr.sel(bands=\"B12\")\n    th   = arr.sel(bands=th_band)          # dims: ('t', 'y', 'x')\n\n    # Expand threshold to match reflectance bands\n    th = th.broadcast_like(b04)             # now dims match ('t','y','x')\n\n    # --- Compute indices ---\n    ndvi = (b08 - b04) / (b08 + b04)\n    nbr  = (b08 - b12) / (b08 + b12)\n    pvir2 = ndvi + nbr                       # dims: ('t','y','x')\n\n    # --- Create mask for each time slice ---\n    mask = pvir2 > th                        # dims: ('t','y','x')\n\n    # Apply mask to all reflectance bands\n    refl_masked = xr.where(mask, np.nan, refl)\n\n    # --- Reduce time dimension ---\n    # refl_mean = refl_masked.mean(dim=\"t\", skipna=True)\n\n    return XarrayDataCube(refl_masked)\n\n\n# def apply_datacube(cube: XarrayDataCube, context: dict) -> XarrayDataCube:\n#     xarr: xr.DataArray = cube.get_array()\n#     # dims: typically ('t',) for apply(), or scalar for reduce_dimension\n# \n#     # reflectance bands (filter by names)\n#     refl_bands = [b for b in xarr.coords[\"bands\"].values if b.startswith(\"B\")]\n#     refl = xarr.sel(bands=refl_bands)\n# \n#     # pvir2 and threshold image\n#     pvir2 = xarr.sel(bands=\"pvir2\")\n#     th    = xarr.sel(bands=\"th_img\")\n# \n#     # mask per pixel, per timestep\n#     mask = pvir2 > th\n# \n#     # apply mask\n#     refl_masked = xr.where(mask, np.nan, refl)\n# \n#     return XarrayDataCube(refl_masked)\n\n\n# def apply_datacube(cube: XarrayDataCube, context: dict) -> XarrayDataCube:\n#     \"\"\"\n#     cube dims: (bands, t, y, x)\n#     \"\"\"\n#     xarr: xr.DataArray = cube.get_array()\n# \n#     # Extract required bands\n#     pvir2  = xarr.sel(bands=\"pvir2\")\n#     th_img = xarr.sel(bands=\"th_img\")\n# \n#     print(\"DEBUG pvir2:\", float(pvir2.min()), float(pvir2.max()))\n#     print(\"DEBUG th_img:\", float(th_img.min()), float(th_img.max()))\n#     print(\"DEBUG ratio:\", float((pvir2 - th_img).min()), float((pvir2 - th_img).max()))\n# \n#     # Mask condition\n#     mask = pvir2 > th_img\n# \n#     # Apply mask only to reflectance bands\n#     refl_bands = [b for b in xarr.bands.values if b.startswith(\"B\")]\n# \n#     result = xarr.copy()\n# \n#     for b in refl_bands:\n#         result.loc[dict(bands=b)] = xr.where(\n#             mask, \n#             result.sel(bands=b), \n#             float(np.nan)\n#         )\n# \n#     # Do not mask pvir2 or threshold band \u2192 keep unchanged\n#     return XarrayDataCube(result)",
                "version": "3.8"
              },
              "result": true
            }
          }
        }
      }
    },
    "reducedimension3": {
      "process_id": "reduce_dimension",
      "arguments": {
        "data": {
          "from_node": "applydimension1"
        },
        "dimension": "t",
        "reducer": {
          "process_graph": {
            "mean1": {
              "process_id": "mean",
              "arguments": {
                "data": {
                  "from_parameter": "data"
                }
              },
              "result": true
            }
          }
        }
      },
      "result": true
    }
  },
  "id": "scmap_composite",
  "summary": "Bare surface composite with statistical producs",
  "description": "Author: paul.karlshoefer@dlr.de\n\nLorem Ipsum",
  "returns": {
    "description": "Bare surface composite with statistical producs",
    "schema": {
      "type": "object",
      "subtype": "datacube"
    }
  },
  "categories": [
    "sentinel-2",
    "composites",
    "bare surface"
  ],
  "parameters": [
    {
      "name": "temporal_extent",
      "description": "Lorem Ipsum",
      "schema": {
        "type": "array",
        "subtype": "temporal-interval",
        "uniqueItems": true,
        "minItems": 2,
        "maxItems": 2,
        "items": {
          "anyOf": [
            {
              "type": "string",
              "subtype": "date-time",
              "format": "date-time"
            },
            {
              "type": "string",
              "subtype": "date",
              "format": "date"
            },
            {
              "type": "null"
            }
          ]
        }
      }
    },
    {
      "name": "bounding_box",
      "description": "Lorem Ipsum",
      "schema": {
        "type": "object",
        "subtype": "bounding-box",
        "required": [
          "west",
          "south",
          "east",
          "north"
        ],
        "properties": {
          "west": {
            "type": "number",
            "description": "West (lower left corner, coordinate axis 1)."
          },
          "south": {
            "type": "number",
            "description": "South (lower left corner, coordinate axis 2)."
          },
          "east": {
            "type": "number",
            "description": "East (upper right corner, coordinate axis 1)."
          },
          "north": {
            "type": "number",
            "description": "North (upper right corner, coordinate axis 2)."
          },
          "crs": {
            "description": "Coordinate reference system of the extent, specified as as [EPSG code](http://www.epsg-registry.org/) or [WKT2 CRS string](http://docs.opengeospatial.org/is/18-010r7/18-010r7.html). Defaults to `4326` (EPSG code 4326) unless the client explicitly requests a different coordinate reference system.",
            "anyOf": [
              {
                "type": "integer",
                "subtype": "epsg-code",
                "title": "EPSG Code",
                "minimum": 1000
              },
              {
                "type": "string",
                "subtype": "wkt2-definition",
                "title": "WKT2 definition"
              }
            ],
            "default": 4326
          }
        }
      },
      "default": {
        "west": 11.1,
        "south": 48.0,
        "east": 11.3,
        "north": 48.2,
        "crs": "EPSG:4326"
      },
      "optional": true
    },
    {
      "name": "max_cloud_cover",
      "description": "Maximum allowed scene-wide cloud cover for the scene to be considered in the composite",
      "schema": {
        "type": "number"
      },
      "default": 80,
      "optional": true
    }
  ]
}